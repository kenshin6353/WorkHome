# 3. Анализ инструментов и подбор архитектуры приложения

Выбор инструментов и архитектуры разработки имеет ключевое значение для создания эффективных мобильных приложений. Правильный выбор позволяет определить возможности приложения и обеспечивает его масштабируемость. Также важно спроектировать архитектуру так, чтобы обновления и новые функциональности можно было легко добавлять без больших изменений в коде.

## 3.1. Выбор инструментов разработки

Нативные технологии iOS SDK [16] и/или кроссплатформенные технологии, такие как Flutter [17], React Native [18], Kotlin Multiplatform Mobile [19], Xamarin [20], и т. д. можно использовать для разработки мобильного приложения для платформы iOS. Конечно, существуют некоторые различия при разработке с использованием нативной и кроссплатформенной технологии.

Разработка с использованием нативных технологий дает множество преимуществ по сравнению с кросс-платформенными, например более высокую производительность, поскольку она оптимизирована для конкретного устройства/операционной системы, повышенную безопасность данных пользователя, качественный UX, широкие функциональные возможности, поскольку предоставляется множество API и библиотек, чтобы приложение могло использовать максимальный потенциал пользовательских устройств, следовательно повысило его масштабируемость. Поэтому для разработки данной работы были выбраны нативные технологии.

Разработка приложений для операционных систем от компании Apple с использованием нативных технологий происходит с помощью одного и/или обоих из следующих языков программирования – Swift [21] и/или Objective-C [22]. Swift является открытым [23], более новым и удобным языком программирования за его читабельность кода, разработанный и поддерживаемый компанией Apple.

Из-за того что этот язык открытый и разработан самой компанией Apple, ошибки будут устраняться быстро, язык также будет поддерживаться для всех устройств, производимых Apple. Более того, всякий раз, когда у мобильного устройства появляется новая функциональность, каждое приложение, разработанное на этом языке, может мгновенно и легко использовать ее, используя свой новый API [24] или библиотеку. Поэтому, разработка данной работы ведется с использованием языка программирования Swift.

### Выбор UI-фреймворка: SwiftUI

Для создания пользовательского интерфейса был выбран фреймворк SwiftUI [25], представленный Apple в 2019 году. SwiftUI является декларативным фреймворком, который позволяет описывать интерфейс в виде функций состояния приложения. Основные преимущества SwiftUI:

- **Декларативный синтаксис** – код описывает желаемый результат, а не последовательность действий для его достижения;
- **Автоматическое управление состоянием** – использование property wrappers (@State, @Binding, @ObservedObject, @Published) для реактивного обновления UI;
- **Кроссплатформенность** – один код работает на iOS, macOS, watchOS и tvOS;
- **Интеграция с Combine** – нативная поддержка реактивного программирования;
- **Live Preview** – мгновенный предпросмотр изменений в Xcode без перекомпиляции.

### Выбор фреймворка для хранения данных: SwiftData

Для локального хранения данных был выбран фреймворк SwiftData [26], представленный Apple в 2023 году как современная замена Core Data. SwiftData обеспечивает:

- **Декларативное определение моделей** – использование макроса @Model для определения сущностей;
- **Автоматическая синхронизация с UI** – интеграция с SwiftUI через @Query и @Environment;
- **Поддержка связей** – использование @Relationship для определения связей между сущностями;
- **Миграция схемы** – автоматическое управление изменениями модели данных;
- **Оптимизированная производительность** – ленивая загрузка и кэширование данных.

## 3.2. Архитектурный подход: SwiftUI App Architecture

Вместо традиционного паттерна MVVM (Model-View-ViewModel), в данном приложении используется современная архитектура SwiftUI App Architecture, которая оптимизирована для работы с декларативным UI и реактивным управлением состоянием [27].

Данная архитектура представляет собой адаптацию классических паттернов проектирования для декларативного фреймворка SwiftUI. Она сохраняет принцип разделения ответственности, но использует механизмы SwiftUI для связывания данных и обновления интерфейса.

### Слой Models (Модели данных)

Слой Models содержит определения структур данных приложения с использованием макроса @Model из SwiftData. Каждая модель представляет сущность предметной области:

- **User** – пользователь приложения с персональными данными и статистикой;
- **Meal** – записи о приемах пищи;
- **FoodItem** – продукты питания с информацией о нутриентах;
- **WorkoutRecord** – записи о тренировках;
- **WeightRecord** – записи измерений веса;
- **UserAchievement** – достижения пользователя;
- **Trainer** – данные о тренерах.

Модели автоматически персистируются в локальную базу данных через ModelContext. Пример определения модели:

```swift
@Model
final class User {
    @Attribute(.unique) var id: UUID
    var firstName: String
    var lastName: String
    var email: String
    var weight: Double
    var height: Double
    
    @Relationship(deleteRule: .cascade) var meals: [Meal]
    @Relationship(deleteRule: .cascade) var workoutHistory: [WorkoutRecord]
}
```

### Слой Views (Представления)

Слой Views отвечает за отображение пользовательского интерфейса. В SwiftUI представления являются структурами, соответствующими протоколу View. Представления автоматически перерисовываются при изменении состояния благодаря механизму property wrappers:

- **@State** – локальное состояние представления;
- **@Binding** – двусторонняя связь с состоянием родительского представления;
- **@ObservedObject** – наблюдение за внешним ObservableObject;
- **@Environment** – доступ к окружению (ModelContext, dismiss и др.);
- **@Query** – автоматическая загрузка данных из SwiftData.

Представления организованы по функциональным модулям:

| Модуль | Описание | Представления |
|--------|----------|---------------|
| Auth | Аутентификация | LoginView, RegisterView |
| Home | Главный экран | HomeView |
| Nutrition | Питание | NutritionView, FoodSearchView |
| Workout | Тренировки | WorkoutListView, WorkoutSessionView |
| Progress | Прогресс | UserProgressView, AchievementsView |
| Profile | Профиль | ProfileView |
| Trainers | Тренеры | TrainersListView, TrainerProfileView |
| Main | Навигация | MainTabView, ContentView |

### Слой Services (Сервисы)

Вместо традиционных ViewModels, приложение использует сервисный слой с ObservableObject классами, которые инкапсулируют бизнес-логику и взаимодействие с внешними системами:

**AuthManager** – управление аутентификацией, регистрацией и сессией пользователя:
- Вход и выход из системы;
- Регистрация новых пользователей;
- Запись тренировок и проверка достижений;
- Управление текущей сессией пользователя.

**HealthKitManager** – интеграция с HealthKit для получения данных о здоровье:
- Запрос авторизации HealthKit;
- Получение количества шагов за день;
- Получение сожженных калорий;
- Получение пройденной дистанции.

**USDAFoodService** – взаимодействие с USDA FoodData Central API:
- Поиск продуктов питания;
- Получение информации о нутриентах;
- Управление состоянием загрузки.

Сервисы реализуют паттерн Singleton для обеспечения единой точки доступа и используют @Published свойства для реактивного обновления UI:

```swift
@MainActor
class HealthKitManager: ObservableObject {
    static let shared = HealthKitManager()
    
    @Published var stepCount: Int = 0
    @Published var caloriesBurned: Double = 0
    @Published var distanceWalked: Double = 0
    @Published var isAuthorized: Bool = false
    
    func fetchTodaySteps() async { ... }
}
```

### Слой Components (Компоненты)

Слой Components содержит переиспользуемые UI-компоненты:

- **CircularProgressView** – круговой индикатор прогресса для отображения шагов и целей;
- **GradientButton** – стилизованная кнопка с градиентом;
- **CardViews** – карточки для отображения информации (MealCard, WorkoutCard и др.).

### Слой Utilities (Утилиты)

Слой Utilities содержит вспомогательные классы и константы:

- **Constants** – константы приложения (цели по умолчанию, ключи UserDefaults, перечисления);
- **Colors** – определения цветов и градиентов для единообразного стиля приложения.

## Преимущества выбранной архитектуры

Из-за того, что логика работы с данными отделена от логики работы с их отображением, изменения в данных не влияют на логику их отображения, и, наоборот. Следовательно, эта архитектура имеет преимущества по сравнению с другими архитектурами такими как MVC [28], и MVP [29]:

- **Упрощенный data binding** – SwiftUI автоматически обновляет UI при изменении @Published свойств, без необходимости ручного связывания;
- **Меньше boilerplate кода** – отсутствие необходимости в отдельных ViewModel классах для каждого View;
- **Нативная интеграция с SwiftData** – использование @Query для автоматической загрузки и обновления данных;
- **Реактивность из коробки** – Combine framework интегрирован в SwiftUI;
- **Тестируемость** – сервисы легко тестировать изолированно от UI;
- **SwiftUI App Architecture имеет высокий уровень связности** среди других архитектур, это означает, что эту архитектуру можно рассматривать как хорошо спроектированную архитектуру.

## 3.3. Пакеты приложения

На рисунке 3.1 приведена диаграмма пакетов данного приложения. В пакете Models хранятся все классы, описывающие модели данных для приложения (User, Meal, WorkoutRecord, WeightRecord, UserAchievement, Trainer, FoodItem). Эти классы относятся к слою Model внутри пакета Models. В пакете Views хранятся все представления, разделенные по функциональным модулям (Auth, Home, Nutrition, Workout, Progress, Profile, Trainers, Main). В пакете Services хранятся сервисные классы, управляющие бизнес-логикой и внешними интеграциями (AuthManager, HealthKitManager, USDAFoodService). В пакете Components хранятся переиспользуемые UI-компоненты интерфейса и экраны приложения, в Utilities – классы-утилиты, содержащие набор вспомогательных функций и инструментов, предоставляющих общие операции, используемые системой.

```
                         ┌─────────────────┐
                         │   Utilities     │
                         │  (Constants,    │
                         │   Colors)       │
                         └────────┬────────┘
                                  │
                                  ▼
     ┌─────────────┐    ┌─────────────────┐    ┌─────────────┐
     │   Views     │◄───│    Services     │───►│   Models    │
     │  (SwiftUI   │    │ (AuthManager,   │    │ (SwiftData  │
     │   Views)    │    │  HealthKit,     │    │  @Model)    │
     │             │    │  USDAFood)      │    │             │
     └──────┬──────┘    └─────────────────┘    └─────────────┘
            │
            ▼
     ┌─────────────┐
     │ Components  │
     │ (Reusable   │
     │  UI parts)  │
     └─────────────┘
```

**Рисунок 3.1 – Пакеты приложения WorkHome**

### Структура проекта в Xcode

```
WORKOUT/
├── WORKOUTApp.swift          # Точка входа приложения
├── ContentView.swift         # Корневое представление
├── Models/
│   ├── User.swift
│   ├── Meal.swift
│   ├── FoodItem.swift
│   ├── WorkoutRecord.swift
│   ├── WeightRecord.swift
│   ├── UserAchievement.swift
│   └── Trainer.swift
├── Views/
│   ├── Auth/
│   │   ├── LoginView.swift
│   │   └── RegisterView.swift
│   ├── Home/
│   │   └── HomeView.swift
│   ├── Nutrition/
│   │   ├── NutritionView.swift
│   │   └── FoodSearchView.swift
│   ├── Workout/
│   │   ├── WorkoutListView.swift
│   │   └── WorkoutSessionView.swift
│   ├── Progress/
│   │   ├── UserProgressView.swift
│   │   └── AchievementsView.swift
│   ├── Profile/
│   │   └── ProfileView.swift
│   ├── Trainers/
│   │   ├── TrainersListView.swift
│   │   └── TrainerProfileView.swift
│   └── Main/
│       └── MainTabView.swift
├── Services/
│   ├── AuthManager.swift
│   ├── HealthKitManager.swift
│   └── USDAFoodService.swift
├── Components/
│   ├── CircularProgressView.swift
│   ├── GradientButton.swift
│   └── CardViews.swift
└── Utilities/
    ├── Constants.swift
    └── Colors.swift
```

### Таблица моделей данных

| Модель | Назначение | Основные свойства |
|--------|------------|-------------------|
| User | Данные пользователя | firstName, lastName, email, weight, height, totalWorkouts, currentStreak |
| Meal | Приемы пищи | date, mealType, totalCalories, foods |
| FoodItem | Продукт питания | name, calories, protein, carbs, fat |
| WorkoutRecord | Запись тренировки | date, workoutType, duration, caloriesBurned |
| WeightRecord | Измерение веса | date, weight |
| UserAchievement | Достижение | achievementId, unlockedAt, progress |
| Trainer | Тренер | name, specialty, rating, whatsappNumber |

### Таблица сервисов

| Сервис | Назначение | Ключевые методы |
|--------|------------|-----------------|
| AuthManager | Аутентификация | login(), register(), logout(), recordWorkoutCompletion() |
| HealthKitManager | HealthKit | requestAuthorization(), fetchTodaySteps(), fetchTodayCalories() |
| USDAFoodService | USDA API | searchFoods(), clearSearch() |
