# 4. Реализация

Реализация данного приложения была проведена с учетом описанной выше архитектуры. При добавлении новой функциональности необходимо определить, к какому слою относятся эти новые классы на основе конкретного правила архитектуры приложения.

## 4.1. Используемые технологии

Для разработки данного приложения используется новый фреймворк SwiftUI. SwiftUI – фреймворк представленный компанией Apple в 2019 году, он построен на декларативном синтаксисе, разработчики могут описывать желаемый пользовательский интерфейс и его поведение с помощью ряда структурированных операторов, а не императивно определять каждый отдельный элемент пользовательского интерфейса. Компания Apple активно развивает этот фреймворк, добавляя новые функциональности каждый год, чтобы этот фреймворк стал заменой ранее использовавшемуся фреймворка UIKit.

В качестве среды разработки использовалась IDE Xcode 15, которая доступна на компьютерах с операционной системой macOS версии 14 или новее. Xcode 15 – бесплатная среда разработки, созданная компанией Apple для разработки приложений для платформ экосистемы Apple [32]. Кроме Xcode, существует среда разработки AppCode [33] от компании JetBrains, однако, есть несколько недостатков, таких как: требуются подписки, еще требует приложение Xcode для работы, и с 14 декабря 2022 года среда разработки AppCode больше не будет получать обновления, поэтому эта среда разработки не будет поддерживать какие-либо будущие дополнительные функции от Apple. Следовательно, данную среду разработки было решено не использовать.

На таблице 4.1 приведен список библиотек, использующихся в данном проекте.

**Таблица 4.1 – Список используемых библиотек**

| № | Название библиотеки | Описание |
|---|---------------------|----------|
| 1 | SwiftData [34] | Фреймворк для локального хранения данных с использованием декларативного синтаксиса |
| 2 | SwiftUI [25] | Декларативный фреймворк для построения пользовательского интерфейса |
| 3 | HealthKit [10] | Центральный репозиторий данных о здоровье и фитнесе на iPhone и Apple Watch |
| 4 | Combine [35] | Фреймворк для реактивного программирования и обработки асинхронных событий |
| 5 | Foundation [36] | Базовые типы данных, коллекции и утилиты операционной системы |

Для хранения кодовой базы использовалась система контроля версий Git вместе с облачной системой управления репозиторий GitHub [37].

## 4.2. Фреймворк SwiftData

Для сохранения каких-то данных от пользователя приложение требует базы данных. В настоящее время существует несколько вариантов баз данных, которые делятся на две категории: реляционная база данных или широко известная как база данных SQL [38] и база данных NoSQL [39] или нереляционная база данных. Основное различие между базой данных SQL и базой данных NoSQL заключается в том, как они структурируют свои данные. Базы данных SQL основаны на таблицах, а базы данных NoSQL основаны на документах, ключах и значениях, графах или хранилищах с широкими столбцами. Хотя использование баз данных SQL дает множество преимуществ, в этом проекте была выбрана база данных с локальным хранением, потому что не требуется синхронизация данных в облаке для нескольких устройств. Кроме того, в этом проекте у нас нет сложных отношений между сущностями, и нам нужно быстрое развитие, которое обеспечивает локальная база данных.

SwiftData – это новый фреймворк от Apple, представленный на WWDC 2023, который предоставляет декларативный подход к определению моделей данных и управлению персистентностью [34]. SwiftData является современной заменой фреймворка Core Data, который использовался в iOS разработке более 15 лет. SwiftData использует локальное хранилище SQLite на устройстве пользователя. Это решение было выбрано по нескольким причинам: во-первых, локальное хранение обеспечивает мгновенный доступ к данным без сетевых задержек; во-вторых, приложение может полноценно работать без подключения к интернету; в-третьих, не требуется настройка серверной инфраструктуры.

SwiftData хранит данные в локальном контейнере на устройстве пользователя. Каждое разрабатываемое приложение имеет свой собственный контейнер по умолчанию, который управляет своим собственным хранилищем данных. Контейнер автоматически создается при первом запуске приложения и сохраняется между сессиями. Сначала нужно чтобы познакомиться с терминами, которые используются в SwiftData. ModelContainer [40] – контейнер, который управляет схемой и конфигурацией хранения данных. ModelContext [41] – контекст, через который выполняются все операции с данными (создание, чтение, обновление, удаление). @Model [42] – макрос, который превращает обычный Swift класс в персистентную сущность базы данных. FetchDescriptor [43] – описание запроса для получения данных с возможностью фильтрации и сортировки. #Predicate [44] – типобезопасный предикат для фильтрации данных.

### Определение моделей данных

SwiftData использует макрос @Model для определения сущностей базы данных. Этот макрос автоматически генерирует весь необходимый код для персистентности, включая методы сериализации и десериализации, отслеживание изменений и интеграцию с SwiftUI. В отличие от Core Data, где требовалось создавать отдельные файлы .xcdatamodeld и вручную генерировать NSManagedObject подклассы, SwiftData позволяет определять модели непосредственно в коде Swift, что значительно упрощает процесс разработки и поддержки кода (рисунок 4.1).

```swift
@Model
final class User {
    @Attribute(.unique) var id: UUID
    var firstName: String
    var lastName: String
    var email: String
    var password: String
    var weight: Double
    var height: Double
    var totalWorkouts: Int
    var currentStreak: Int
    
    // Связи с другими сущностями
    @Relationship(deleteRule: .cascade) var meals: [Meal]
    @Relationship(deleteRule: .cascade) var workoutHistory: [WorkoutRecord]
    @Relationship(deleteRule: .cascade) var achievements: [UserAchievement]
    
    init(firstName: String, lastName: String, email: String, ...) {
        self.id = UUID()
        self.firstName = firstName
        // ...
    }
}
```

**Рисунок 4.1 – Листинг программы модели User с использованием макроса @Model**

В данном листинге программы показана модель User, которая представляет пользователя приложения. Декоратор @Attribute(.unique) указывает, что поле id должно быть уникальным в базе данных, что предотвращает создание дублирующихся записей. Модель содержит персональные данные пользователя (имя, email, возраст, рост, вес), а также статистику фитнеса (количество тренировок, текущая серия, очки, уровень). Инициализатор устанавливает значения по умолчанию для статистических полей, что гарантирует корректное начальное состояние для новых пользователей.

### Связи между сущностями

SwiftData поддерживает определение связей между сущностями с помощью декоратора @Relationship. Это позволяет создавать сложные структуры данных с отношениями один-к-одному, один-ко-многим и многие-ко-многим. В данном приложении используются связи один-ко-многим, где один пользователь может иметь множество записей о приемах пищи, тренировках, измерениях веса и достижениях. Параметр deleteRule определяет поведение при удалении родительской записи (рисунок 4.2).

```swift
// Связь один-ко-многим: User -> Meals
@Relationship(deleteRule: .cascade) var meals: [Meal]

// Связь один-ко-многим: User -> WorkoutRecords  
@Relationship(deleteRule: .cascade) var workoutHistory: [WorkoutRecord]

// Связь один-ко-многим: User -> WeightRecords
@Relationship(deleteRule: .cascade) var weightRecords: [WeightRecord]

// Связь один-ко-многим: User -> UserAchievements
@Relationship(deleteRule: .cascade) var achievements: [UserAchievement]

// Связь один-ко-многим: Meal -> FoodItems
@Relationship(deleteRule: .cascade) var foods: [FoodItem]
```

**Рисунок 4.2 – Листинг программы связей между сущностями с каскадным удалением**

Параметр deleteRule: .cascade указывает, что при удалении родительской записи (User) все связанные дочерние записи (Meals, WorkoutRecords, WeightRecords, UserAchievements) также будут автоматически удалены из базы данных. Это важно для поддержания целостности данных и предотвращения появления "осиротевших" записей, которые ссылаются на несуществующего пользователя. Альтернативные правила удаления включают .nullify (установка ссылки в null), .deny (запрет удаления при наличии связанных записей) и .noAction (игнорирование связей).

## 4.3. Фреймворк SwiftData и SwiftDataManager

Для доступа к базе данных приложения было принято решение создать к ней единую точку доступа. В данном приложении для работы с локальной базой данных используется фреймворк SwiftData, который предоставляет декларативный и типобезопасный способ работы с персистентными данными. Аналогично тому, как в приложениях с CloudKit создается класс CloudKitManager для абстрагирования операций с облачной базой данных, в данном приложении создан класс SwiftDataManager (в коде называется AuthManager), который инкапсулирует все операции с локальной базой данных SwiftData.

Этот класс SwiftDataManager состоит из нескольких методов для работы с базой данных, таких как выборка (fetch), удаление (delete), обновление (update) и сохранение (save) данных в базе данных. В реализации этого класса используется паттерн Singleton [52] (Одиночка), поскольку этот паттерн гарантирует, что в приложении существует только один экземпляр этого объекта. Таким образом, необходимость повторной инициализации объекта SwiftDataManager всякий раз, когда модель представления запрашивает запрос к SwiftDataManager, или необходимость передачи экземпляра SwiftDataManager нескольким моделям представления не требуется.

Также в этом классе данные пользователя будут сохраняться при каждом запуске приложения, где при каждом запуске значение данных этого пользователя может изменяться, поскольку пользователь меняет свою учетную запись на своем устройстве или выходит из своей учетной записи на своем устройстве. Следовательно, для отслеживания этих изменений и уведомления пользователя с помощью предупреждения необходимо использовать одноэлементный класс. Еще одна причина, по которой паттерн одиночка использовался для реализации класса SwiftDataManager, заключается в том, что Apple iOS SDK широко использует паттерн «Одиночка» [53], например: URLSession.shared [54] — объект, который координирует группу связанных задач передачи данных по сети, этот объект обычно используется для выполнения сетевых вызовов внешнего API; UserDefaults.standard [55] — объект пользовательской базы данных по умолчанию, где пользователь может постоянно хранить пары ключ-значение при запуске приложения.

На рисунке 4.3 приведена диаграмма классов от этого класса SwiftDataManager, следует отметить, что этот класс имеет зависимости с ModelContext для выполнения операций с базой данных SwiftData.

```
┌─────────────────────────────────────────────────────────────┐
│                    SwiftDataManager                          │
├─────────────────────────────────────────────────────────────┤
│ + shared: SwiftDataManager                                   │
│ + currentUser: User?                                         │
│ + isLoggedIn: Bool                                          │
├─────────────────────────────────────────────────────────────┤
│ + fetch<T>(descriptor:) throws -> [T]                        │
│ + insert(_:)                                                 │
│ + delete(_:)                                                 │
│ + save() throws                                              │
│ + login(email:password:modelContext:) -> Bool                │
│ + register(firstName:lastName:email:...:modelContext:) -> Bool│
│ + logout()                                                   │
│ + loadCurrentUser(modelContext:)                             │
│ + recordWorkoutCompletion(workoutType:duration:...:modelContext:) │
│ - checkAchievements(for:modelContext:)                       │
│ - updateStreak(for:)                                         │
└─────────────────────────────────────────────────────────────┘
```

**Рисунок 4.3 – Диаграмма классов класса SwiftDataManager**

Основное отличие SwiftDataManager от CloudKitManager заключается в том, что SwiftData работает с локальным хранилищем на устройстве, в то время как CloudKit работает с облачным хранилищем iCloud. Это означает, что все операции в SwiftDataManager выполняются синхронно и мгновенно, без необходимости обработки сетевых задержек или ошибок подключения. Для выполнения операций с базой данных SwiftDataManager использует ModelContext, который предоставляется через механизм @Environment в SwiftUI.

### Метод login() – Чтение данных (READ)

Метод login() был создан для получения записи текущего пользователя (рисунок 4.4). Во-первых, чтобы получить запись пользователя, необходимо создать FetchDescriptor с предикатом, который фильтрует пользователей по email и password. FetchDescriptor является типобезопасным способом описания запроса к базе данных, а макрос #Predicate позволяет создавать условия фильтрации с проверкой типов на этапе компиляции. Этот completionHandler завершения возвращает как массив найденных пользователей, так и ошибку, затем необходимо проверить, произошла ли ошибка в процессе выборки или нет, используя метод guard let [57]. Следует отметить, что результат запроса является массивом пользователей, но поскольку email является уникальным полем, массив будет содержать максимум один элемент. Если пользователь найден, его данные сохраняются в свойство currentUser, а флаг isLoggedIn устанавливается в true. Хорошей практикой является сохранение идентификатора пользователя в UserDefaults для восстановления сессии при следующем запуске приложения.

```swift
func login(email: String, password: String, modelContext: ModelContext) -> Bool {
    // Создание дескриптора запроса с предикатом
    let descriptor = FetchDescriptor<User>(
        predicate: #Predicate { user in
            user.email == email && user.password == password
        }
    )
    
    do {
        // Выполнение запроса к базе данных
        let users = try modelContext.fetch(descriptor)
        
        if let user = users.first {
            // Пользователь найден - сохраняем в сессию
            currentUser = user
            isLoggedIn = true
            
            // Сохраняем ID в UserDefaults для восстановления сессии
            UserDefaults.standard.set(true, forKey: Constants.UserDefaultsKeys.isLoggedIn)
            UserDefaults.standard.set(user.id.uuidString, forKey: Constants.UserDefaultsKeys.currentUserID)
            
            return true
        }
    } catch {
        print("Login error: \(error)")
    }
    
    return false
}
```

**Рисунок 4.4 – Листинг программы метода для аутентификации пользователя**

### Метод register() – Создание данных (CREATE)

Методы save() и insert() используются для записи и создания данных в базу данных SwiftData (рисунок 4.5). Основное отличие между ними состоит в том, что insert() добавляет новый объект в контекст, а save() фиксирует все изменения в постоянное хранилище. При создании новой записи сначала необходимо проверить, не существует ли уже пользователь с таким email, поскольку это поле должно быть уникальным для каждого пользователя. Чтобы создать одну или несколько записей, сначала необходимо создать объект модели с помощью инициализатора, заполнив все необходимые поля. Затем объект добавляется в контекст с помощью метода insert(), и изменения сохраняются с помощью метода save(). В SwiftData, в отличие от Core Data, не требуется явно вызывать save() после каждой операции – контекст автоматически сохраняет изменения в определенные моменты. Однако для гарантии сохранения критически важных данных рекомендуется вызывать save() явно.

```swift
func register(
    firstName: String, lastName: String, email: String,
    password: String, age: Int, height: Double,
    weight: Double, fitnessGoal: String,
    modelContext: ModelContext
) -> Bool {
    // Проверка на существование пользователя с таким email
    let descriptor = FetchDescriptor<User>(
        predicate: #Predicate { user in
            user.email == email
        }
    )
    
    do {
        let existingUsers = try modelContext.fetch(descriptor)
        if !existingUsers.isEmpty {
            return false // Email уже существует
        }
        
        // Создание нового пользователя
        let newUser = User(
            firstName: firstName,
            lastName: lastName,
            email: email,
            password: password,
            age: age,
            height: height,
            weight: weight,
            fitnessGoal: fitnessGoal
        )
        
        // Создание начальной записи веса
        let initialWeight = WeightRecord(weight: weight)
        newUser.weightRecords.append(initialWeight)
        
        // Вставка в базу данных
        modelContext.insert(newUser)
        try modelContext.save()
        
        return true
    } catch {
        print("Registration error: \(error)")
        return false
    }
}
```

**Рисунок 4.5 – Листинг программы метода для регистрации нового пользователя**

### Метод recordWorkoutCompletion() – Обновление данных (UPDATE)

В SwiftData для обновления записи используется простой подход: достаточно изменить свойства объекта, и изменения будут автоматически отслежены контекстом. Затем метод save() используется для сохранения всех изменений в базу данных (рисунок 4.6). Метод recordWorkoutCompletion() вызывается после завершения пользователем тренировки. Он выполняет несколько операций: обновляет статистику пользователя (общее количество тренировок, сожженные калории, очки), проверяет и обновляет серию тренировок (streak), создает новую запись в истории тренировок и проверяет, разблокировал ли пользователь новые достижения. Все эти операции выполняются в рамках одной транзакции для обеспечения целостности данных.

```swift
func recordWorkoutCompletion(
    workoutType: String,
    duration: Int,
    caloriesBurned: Int,
    exercisesCompleted: Int,
    modelContext: ModelContext
) {
    guard let user = currentUser else { return }
    
    // Обновление статистики пользователя (UPDATE)
    user.totalWorkouts += 1
    user.totalCaloriesBurned += caloriesBurned
    user.totalPoints += 50
    
    // Обновление streak
    updateStreak(for: user)
    
    // Создание записи тренировки (CREATE)
    let workoutRecord = WorkoutRecord(
        workoutType: workoutType,
        duration: duration,
        caloriesBurned: caloriesBurned,
        exercisesCompleted: exercisesCompleted
    )
    user.workoutHistory.append(workoutRecord)
    
    // Проверка достижений
    checkAchievements(for: user, modelContext: modelContext)
    
    // Сохранение изменений
    try? modelContext.save()
}
```

**Рисунок 4.6 – Листинг программы метода для записи завершенной тренировки**

### Удаление данных (DELETE)

Чтобы удалить запись из базы данных, используется метод delete() контекста модели (рисунок 4.7), который принимает объект для удаления в качестве параметра. Поскольку пользователь может редактировать/удалять только записи о своих тренировках и приемах пищи, необходимо только удалить данные из локальной базы данных. При удалении родительской записи важно учитывать связанные дочерние записи. Благодаря настройке deleteRule: .cascade в декораторе @Relationship, все связанные записи удаляются автоматически. Например, при удалении объекта Meal все связанные объекты FoodItem также будут удалены из базы данных.

```swift
// Пример удаления записи из базы данных
func deleteWorkoutRecord(_ record: WorkoutRecord, modelContext: ModelContext) {
    modelContext.delete(record)
    try? modelContext.save()
}

// Пример удаления приема пищи
func deleteMeal(_ meal: Meal, modelContext: ModelContext) {
    // Каскадное удаление - все связанные FoodItem также удалятся
    modelContext.delete(meal)
    try? modelContext.save()
}
```

**Рисунок 4.7 – Листинг программы методов для удаления записей**

### Проверка достижений – checkAchievements()

Метод checkAchievements() проверяет, разблокировал ли пользователь новые достижения после обновления статистики (рисунок 4.8).

```swift
private func checkAchievements(for user: User, modelContext: ModelContext) {
    // Создание множества уже разблокированных ID для O(1) поиска
    let unlockedIds = Set(user.achievements.map { $0.achievementId })
    
    // Проверка достижений по количеству тренировок
    let workoutAchievements = [
        ("workout_1", 1), ("workout_10", 10), 
        ("workout_50", 50), ("workout_100", 100)
    ]
    
    for (achievementId, requirement) in workoutAchievements {
        if !unlockedIds.contains(achievementId) && 
           user.totalWorkouts >= requirement {
            // Создание нового достижения
            let achievement = UserAchievement(
                achievementId: achievementId, 
                progress: user.totalWorkouts
            )
            user.achievements.append(achievement)
            
            // Начисление очков
            if let achDef = AchievementManager.achievement(for: achievementId) {
                user.totalPoints += achDef.points
            }
        }
    }
    
    // Обновление уровня
    user.level = (user.totalPoints / 1000) + 1
}
```

**Рисунок 4.8 – Листинг программы метода для проверки достижений**

## 4.4. Environment Object и ObservableObject

Для ускорения работы этого приложения необходимо минимизировать количество обращений к базе данных (получение данных о пользователе). Поэтому было решено создать класс, который сохраняет все данные, в общем, всякий раз, когда пользователь запускает приложение, приложение загружает данные пользователя, чтобы заполнить все представления актуальной информацией. Поскольку данные пользователя не сильно меняются в течение некоторого периода времени и будет меняться только тогда, когда пользователь завершает тренировку, добавляет прием пищи или обновляет измерения, логично сохранить и кэшировать эти данные.

Если пользователь добавит новую тренировку в историю, система обновит данные в SwiftDataManager, и, если данные будут успешно сохранены в базе данных SwiftData, все связанные представления автоматически обновятся благодаря механизму @Published. И наоборот, когда пользователь удаляет запись, система пытается удалить её из базы данных, затем удаляет из локального кэша в SwiftDataManager.

Хотя можно сделать этот класс объектом Singleton, который реализует наблюдаемый протокол интерфейса объекта, но, поскольку паттерн одиночка не является действительно хорошим паттерном проектирования, весьма вероятно, что могут возникать ошибки, поскольку этот класс объектов инициируется глобально, поэтому любой метод или класс в кодовой базе этого приложения имеет доступ к этому классу и могут вносить изменения в этот одноэлементный класс. Хотя в этом приложении оба этих класса будут использоваться только в некоторых методах модели представления и в некоторых представлениях, необходимо найти другое решение, которое можно применить, чтобы избежать использования паттерна одиночка.

В Swift есть обёртка свойств @EnvironmentObject, которую можно применить к классу, реализующему протокол ObservableObject [64], который помогает обмениваться данными между представлениями [67]. Эта обёртка свойств может гарантировать, что только те части представлений, которые должны получить доступ к этому классу, предоставляя эти дочерние представления из родительских представлений с модификатором .environmentObject() [68]. В этом случае было решено, что использование быстрой оболочки свойств @EnvironmentObject и передача этого объекта с помощью модификатора .environmentObject() помогает поддерживать то, что из этих классов создается только один экземпляр, а те представления или методы моделей представления, которым они нужны, имеют доступ к этому.

На рисунке 4.9 приведена диаграмма классов класса SwiftDataManager, который реализует протокол ObservableObject и используется для управления данными пользователя и операциями с базой данных.

```
┌─────────────────────────────────────────────────────────────────┐
│                    SwiftDataManager                              │
├─────────────────────────────────────────────────────────────────┤
│ + shared: SwiftDataManager               «static»                │
│ + currentUser: User?                     «@Published»            │
│ + isLoggedIn: Bool                       «@Published»            │
├─────────────────────────────────────────────────────────────────┤
│ - init()                                 «private»               │
│ + login(email:password:modelContext:) -> Bool                    │
│ + register(firstName:...modelContext:) -> Bool                   │
│ + logout()                                                       │
│ + recordWorkoutCompletion(...modelContext:)                      │
└─────────────────────────────────────────────────────────────────┘
```

**Рисунок 4.9 – Диаграмма классов класса SwiftDataManager, реализующего ObservableObject**

Оба класса SwiftDataManager и HealthKitManager создаются в точке входа приложения и передаются в иерархию представлений с помощью .environmentObject() (рисунок 4.10). Декоратор @StateObject используется для создания объектов, которые должны сохраняться на протяжении всего жизненного цикла приложения. Модификатор .environmentObject() передает эти объекты во все дочерние представления через механизм окружения SwiftUI. Модификатор .modelContainer() настраивает контейнер SwiftData со списком всех моделей, которые будут персистироваться.

```swift
@main
struct WORKOUTApp: App {
    // Создание экземпляров сервисов как @StateObject
    // @StateObject гарантирует, что объект создается один раз
    @StateObject private var swiftDataManager = SwiftDataManager.shared
    @StateObject private var healthKitManager = HealthKitManager.shared
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                // Передача объектов в иерархию представлений
                .environmentObject(swiftDataManager)
                .environmentObject(healthKitManager)
                // Настройка контейнера SwiftData для моделей данных
                .modelContainer(for: [
                    User.self,
                    Meal.self,
                    FoodItem.self,
                    WorkoutRecord.self,
                    WeightRecord.self,
                    UserAchievement.self
                ])
        }
    }
}
```

**Рисунок 4.10 – Листинг программы структуры, реализующая протокол App (точка входа приложения), где создаются сервисы для управления данными**

## Сводная таблица CRUD операций в SwiftData

| Операция | Метод SwiftData | Описание | Пример в приложении |
|----------|-----------------|----------|---------------------|
| **CREATE** | `modelContext.insert()` | Добавление нового объекта в контекст | Регистрация пользователя, добавление тренировки |
| **READ** | `modelContext.fetch()` | Получение объектов по критериям | Вход в систему, загрузка истории тренировок |
| **UPDATE** | Изменение свойств объекта | Автоматическое отслеживание изменений | Обновление статистики, изменение измерений веса |
| **DELETE** | `modelContext.delete()` | Удаление объекта из контекста | Удаление записи тренировки или приема пищи |
